<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Cache-Control" content="no-store">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kiosk Screensaver</title>
    <style>
      html, body {
        margin: 0; padding: 0;
        width: 100%; height: 100%;
        overflow: hidden; background: black;
      }

      /* Prevent "drag image -> new tab / navigate to image" behavior */
      #screensaver-image {
        -webkit-user-drag: none;
        user-select: none;
        -webkit-user-select: none;
        pointer-events: none; /* exit listeners are on window/document, so this is safe */
      }
    </style>
  </head>
  <body>
    <div id="screensaver" class="fixed inset-0">
      <% if @slides.any? %>
        <img
          id="screensaver-image"
          draggable="false"
          style="position:absolute; top:0; left:0; width:100%; height:100%; object-fit:cover;"
        />
      <% else %>
        <div style="display:flex; align-items:center; justify-content:center; width:100%; height:100%;">
          <p style="color:white; font-size:24px;">No slides scheduled.</p>
        </div>
      <% end %>
    </div>

    <script>
      // --- Sticky Params ---
      window.kioskCode = "<%= params[:kiosk].to_s.gsub('"','') %>";
      window.kioskHost = "<%= params[:host].to_s.gsub('"','') %>";
      function stickyUrl(path) {
        let url = path.includes('?') ? path : path + '?';
        if (!/(\?|&)kiosk=/.test(url)) url += (url.endsWith('?') ? '' : '&') + 'kiosk=' + encodeURIComponent(window.kioskCode || '');
        if (window.kioskHost && !/(\?|&)host=/.test(url)) url += '&host=' + encodeURIComponent(window.kioskHost);
        return url;
      }

      document.addEventListener("DOMContentLoaded", () => {
        const REFRESH_INTERVAL = 30 * 60 * 1000; // 30m

        // Build slide list (may be empty)
        let slides = <%= raw(@slide_data.to_json) %>;
        let idx = 0;
        const img = document.getElementById("screensaver-image");

        // Extra safety: if something tries to drag/open the image anyway, block it.
        if (img) {
          img.addEventListener("dragstart", (e) => { try { e.preventDefault(); } catch {} }, { capture: true });
          img.addEventListener("contextmenu", (e) => { try { e.preventDefault(); } catch {} }, { capture: true });
        }

        // ---- timers / bookkeeping ----
        let slideTimer = null;
        let navigating = false;

        const nowMs = () => Date.now();
        let lastSlideAdvanceAt = nowMs();
        let expectedSlideMs = 10 * 1000;

        // ----- Exit wiring (always on, robust) -----
        const MOVE_GRACE_MS   = 350;  // ignore immediate synthetic moves
        const MOVE_THRESHOLD  = 14;   // px combined movement
        const startedAt       = performance.now();

        function exit(reason) {
          if (navigating) return;
          navigating = true;

          if (slideTimer) clearTimeout(slideTimer);

          try { navigator.vibrate?.(50); } catch {}

          // If navigation gets blocked for any reason, allow a retry shortly after.
          const rearm = setTimeout(() => { navigating = false; }, 2000);
          window.addEventListener("pagehide",   () => clearTimeout(rearm), { once: true });
          window.addEventListener("beforeunload", () => clearTimeout(rearm), { once: true });

          window.location.replace(stickyUrl("/exit"));
        }

        // Fire on “definite” input events
        const wakeEvents = ["pointerdown", "mousedown", "touchstart", "keydown", "wheel"];
        wakeEvents.forEach((evt) => {
          window.addEventListener(evt, exit,   { capture: true, passive: true });
          document.addEventListener(evt, exit, { capture: true, passive: true });
        });

        // Movement exit (throttled + threshold + capture)
        let firstMove = null;
        let pendingMove = null;
        let rafScheduled = false;

        function onMove(x, y) {
          if (navigating) return;
          if (performance.now() - startedAt < MOVE_GRACE_MS) return;

          pendingMove = { x, y };
          if (rafScheduled) return;

          rafScheduled = true;
          requestAnimationFrame(() => {
            rafScheduled = false;
            const p = pendingMove;
            pendingMove = null;
            if (!p) return;

            if (!firstMove) { firstMove = p; return; }

            const dx = Math.abs(p.x - firstMove.x);
            const dy = Math.abs(p.y - firstMove.y);
            if ((dx + dy) >= MOVE_THRESHOLD) exit("move");
          });
        }

        function onPointerMove(e) { onMove(e.clientX, e.clientY); }
        function onMouseMove(e)   { onMove(e.clientX, e.clientY); }

        window.addEventListener("pointermove", onPointerMove, { capture: true, passive: true });
        document.addEventListener("pointermove", onPointerMove, { capture: true, passive: true });
        window.addEventListener("mousemove", onMouseMove, { capture: true, passive: true });
        document.addEventListener("mousemove", onMouseMove, { capture: true, passive: true });

        // ----- Slideshow (with watchdog + error fallback) -----
        function shuffle(arr) {
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
        }

        function clampDurationSeconds(n) {
          const x = Number(n);
          if (!Number.isFinite(x)) return 10;
          return Math.max(3, Math.min(10 * 60, x));
        }

        function safeSlideUrl(u) {
          // Only allow http(s) URLs; avoids any weirdness if slide data is bad.
          try {
            const parsed = new URL(String(u), window.location.origin);
            if (parsed.protocol !== "http:" && parsed.protocol !== "https:") return null;
            return parsed.toString();
          } catch (e) {
            return null;
          }
        }

        function showCurrentSlide() {
          if (!img || !slides.length) return;

          const s = slides[idx];
          expectedSlideMs = clampDurationSeconds(s.duration) * 1000;

          const u = safeSlideUrl(s.url);
          if (!u) {
            setTimeout(() => { if (!navigating) nextSlide(); }, 250);
            return;
          }

          img.src = u;
          img.alt = s.title || "";
        }

        function scheduleNext() {
          if (!slides.length) return;
          if (slideTimer) clearTimeout(slideTimer);

          const ms = expectedSlideMs || 10 * 1000;
          slideTimer = setTimeout(nextSlide, ms);
        }

        function nextSlide() {
          if (!slides.length) return;
          idx = (idx + 1) % slides.length;
          showCurrentSlide();
          scheduleNext();
        }

        function startSlideshow() {
          if (!slides.length || !img) return;
          idx = 0;
          shuffle(slides);
          showCurrentSlide();
          scheduleNext();
        }

        if (img) {
          img.addEventListener("load", () => { lastSlideAdvanceAt = nowMs(); }, { passive: true });
          img.addEventListener("error", () => {
            setTimeout(() => { if (!navigating) nextSlide(); }, 1500);
          }, { passive: true });
        }

        if (slides.length && img) startSlideshow();

        // Watchdog: if the slideshow stalls, advance.
        setInterval(() => {
          if (navigating) return;
          if (!slides.length || !img) return;

          const msSince = nowMs() - lastSlideAdvanceAt;
          const stallThreshold = (expectedSlideMs || 10000) + 45000; // duration + 45s
          if (msSince > stallThreshold) {
            nextSlide();
          }
        }, 15000);

        // ----- Periodic refresh (even if empty) -----
        setInterval(async () => {
          try {
            const res = await fetch(stickyUrl("/slides.json"), { cache: "no-store" });
            if (!res.ok) throw new Error(res.statusText);
            const json = await res.json();
            const updated = json && json.slides;

            if (Array.isArray(updated) && updated.length) {
              slides = updated;
              if (img) startSlideshow();
            }
          } catch (e) {
            console.error("Slide refresh failed:", e);
          }
        }, REFRESH_INTERVAL);
      });
    </script>
  </body>
</html>
